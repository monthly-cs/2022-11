# **프로세스와 스레드의 차이**

이 문서는 2022년 11월 20일에 @kwanyung에 의해서 작성되었습니다.

```
1. Thread-safe
    - 멀티 스레드
    - 멀티 스레드의 문제점?
    - Thread-safe
2. PCB
    - 프로세스 관리
    - PCB
    - PCB의 관리 방식
3. Context Switching
    - 정의
    - 수행 과정
    - 비용
```

# 1. **Thread-safe**

## 1-1. **멀티 스레드**

- Node.js를 접하면 가장 많이 듣는 용어인 `단일 스레드`
  - 때문에 JS를 사용하는 개발자에게는 와닿지 않는 용어

## 멀티스레드?

- 여러 클라이언트에서 오는 요청을 동시에 여러개의 스레드로 처리.
- 대표적으로 JAVA는 멀티스레드 처리 방식을 지원함.
 
<img width="951" alt="싱글 vs 멀티" src="https://user-images.githubusercontent.com/71562311/203041915-f7b8e2f2-590f-41de-b3c4-80de66ed8a40.png">

## 1-2 **멀티 스레드의 문제점?**

최초 value의 값은 0

```
value++
```


![스레드 안정성](https://user-images.githubusercontent.com/71562311/203041948-f32f0cb7-abc1-478e-9b55-d5aa43dde671.PNG)

value++

- 위 작업은 단일 작업으로 보이지만 사실 3개의 작업이 동작!
  > 1. 메모리에서 value값을 CPU 레지스터로 가져옴
  > 2. value의 값을 1 증가시킴
  > 3. 1 증가된 value 값을 다시 메모리로 되돌려줌.

두 개의 스레드가 위의 작업을 수행하는 경우

- A스레드에서 value = 0을 읽어 값을 로드
- B스레드에서 value = 0을 읽어 값을 로드
- A스레드에서 value ++ 을 수행해 값을 1 증가시킴
- B스레드에서 value ++ 을 수행해 값을 1 증가시킴
- 두 스레드 모두 1이라는 값을 반환시킴
- 당연히 2라는 값이 반환되어야 하지 않을까?

스레드는 기본적으로 코드를 공유하기 때문에 전역변수 등을 공유하게 됨.
<br> => 많은 스레드에서 동시에 접근

## 1-3 **Thread-safe**

- 여러 스레드에서 클래스 혹은 클래스의 객체에 동시에 접근해서 사용하더라도 정확하게 동작함

1-2와 같은경우는 `스레드 안전하지 않다` 라고 볼 수 있는 것!

`스레드 안전한 상태`를 위해서는 다음 세가지 방법으로 처리해야함.

1. 공유되는 상태 변수를 스레드 간 공유되지 않도록 바꾸기
2. 공유되는 상태 변수를 변경할 수 없게 만들기
3. 공유되는 상태 변수를 사용할 때 항상 동기화

JAVA에서는 synchronized 키워드를 메서드 앞에 붙여 하나의 스레드만 instance 변수를 보고 판단해 객체를 생성하고록 강제할 수 있음.

동기화 (Synchronized)란?

- 하나 이상의 Thread가 어떤 로직에 동시에 접근했을 때, 그 연산에 대한 값의 무결성을 보장하기 위해 수행 영역에 대한 lock을 걸어주는 것.

---

# 2. **PCB(Process Controll Block)**

## 2-1 **프로세스 관리**

- 구동중인 프로세스가 여러 개일 때, CPU 스케줄링을 이용해 프로세스를 관리하는 것.
  - CPU는 각 프로세스가 고유하게 가지는 `Process Metadata`를 활용해 프로세스를 구분.

프로세스 메타데이터가 담고있는 정보

- 프로세스 고유 ID (PID)
- 프로세스 상태
- 프로세스 우선순위
- Program Counter (PC)
- CPU 레지스터
- Owner
- Memory Limit
- 기타 등등

## 메타데이터는 프로세스가 생성될 때 `PCB`에 저장!

---

## 2-2 **PCB**

![PCB](https://user-images.githubusercontent.com/71562311/203041984-ffa88a3d-5441-413f-a894-ef0659b9396b.png)

- 한 PCB안에는 한 프로세스의 정보가 담김.
- 프로그램이 실행되어 메모리에 적재될 때
  - 프로세스 생성
  - 프로세스 주소 공간에 코드&데이터&스택 공간이 생성
  - 이후 해당 프로세스의 메타데이터들이 PCB에 저장

<br>
CPU에서는 프로세스의 상태에 따라
프로세스 교체작업(Context Switching) 을 진행!

> 이 교체작업을 계획하는 것을 CPU 스케줄링이라고 합니다!
> [@unchaptered님 스케줄링](https://github.com/monthly-cs/2022-11/blob/main/CPU%20%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81/3.%20CPU%20%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%AC.md)

Context Switching은 현재 진행중인 프로세스에 `인터럽트`를 발생시키고 다른 프로세스를 `진행` 상태로 만드는 작업

## 만약!

인터럽트를 발생시킨 프로세스 작업으로 돌아가려는데 정보를 잃어버려 프로그램을 다시 시작해야 한다면..?

## `이러한 일을 방지하기 위해 대기 상태에 들어가기 전 실행 정보를 PCB에 저장하는 것!`

---

## 2-3 **PCB의 관리**

[링크드 리스트 정의](https://github.com/dailythm/dailythm-GwonYeong/blob/main/%EC%96%B4%EC%84%9C%EC%99%80!%20%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%99%80%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%80%20%EC%B2%98%EC%9D%8C%EC%9D%B4%EC%A7%80(%EB%AC%BC%EC%9D%8C%ED%91%9C)/Lesson%207.md)

PCB는 `새로운 값을 삽입하거나, 특정한 값을 삭제하는 데 유리한` Linked List로 이루어져 있음.

> 프로세스가 종료되면 PCB도 제거!

---

# 3. **Context Switching(문맥 교환)**

## 3-1 **정의**

`Context : 현재 CPU가 실행하고 있는 프로세스의 정보`

- CPU가 현재 실행하고 있는 Task(Process, Thread)의 상태를 저장하고, 다음 진행할 Task의 상태 및 Register 값들에 대한 정보(Context)를 읽어 새로운 Task의 Context 정보로 교체하는 과정

```
CPU는 동시가 아닌 엄청나게 빠른 속도로 프로세스를 하나씩 처리함.

이 과정에서 처리할 프로세스를 계속 바꿔줘야 하는데 이 작업을 Context Switching이라고 하는 것!
```

---

## 3-2 **수행 과정**


<img width="665" alt="컨텍스트 스위칭" src="https://user-images.githubusercontent.com/71562311/203042030-6ca57956-c72c-43b9-a58c-610feb0b9e0e.png">

1. P0 프로세스가 인터럽트되면서 PCB0에 P0 프로세스의 상태 정보를 저장.
2. 다음 수행할 P1 프로세스의 PCB1에서 P1 프로세스의 상태 정보가 CPU에 재로딩.
3. P1 프로세스를 일정 시간 수행.
4. P1 프로세스가 인터럽트되면서 PCB1에 P1 프로세스의 상태 정보를 저장.
5. 다음 수행할 P0 프로세스의 PCB0에서 P0 프로세스의 상태 정보가 CPU에 재로딩.
6. P0 프로세스를 일정 시간 수행.

---

## 3-3 **비용**

- 기본적으로 Context Switching은 많은 비용을 발생 시킴!
- 그래서 다중 프로세스보다 다중 스레드 방식을 많이 사용하는 것!
  - 스레드는 스택을 제외한 데이터를 공유하기 때문에 스택만 바꾸어주면 되기 때문.

기본적으로 다음과 같은 비용을 소모.

1. Cache 초기화
2. Memory Mapping 초기화
3. 메모리의 접근을 위해 항상 Kernel 실행

때문에 Context Switching을 최소화 하면서도 여러개의 프로세스를 동시에 처리하는 느낌을 가지게 해야함!

- 시간 할당량이 적어지면 : Context Switching 수, 인터럽트 횟수, 오버헤드가 증가하지만 여러 개의 프로세스가 동시에 수행되는 느낌을 갖는다.

- 시간 할당량이 커지면 : Context Switching 수, 인터럽트 횟수, 오버헤드가 감소하지만 여러 개의 프로세스가 동시에 수행되는 느낌을 갖지 못한다.
