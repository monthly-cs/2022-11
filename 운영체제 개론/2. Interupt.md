# **Interupt**

이 문서는 2022년 11월 04일에 @kwanyung에 의해서 작성되었습니다.

1. 인터럽트란?

    1-1. 소프트웨어 인터럽트<br>
    1-2. 외부 인터럽트

2. 인터럽트의 정렬 방법

    2-1. 소프트웨어적 방법<br>
    2-2. 하드웨어적 방법

3. 인터럽트의 처리

---

# 1. **인터럽트란?**

선생님이 한참 설명을 진행하고 계시는데... 중간에 손을 들어 질문을 한다면?

이런 상황을 `인터럽트` 라고 함!

-   운영체제는 항상 CPU의 효율을 최대로 끌어올리고 싶어함.
-   대부분의 컴퓨터는 한 개의 CPU를 사용하기에 한 순간에 하나의 일만 처리할 수 있음.
    -   어떤 일을 처리하는 도중 우선 순위가 급한 일을 처리할 수 있는 방안이 필요!

> **CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등 장치나 예외상황이 발생해 처리가 필요한 경우 마이크로프로세서에게 알려 처리 할 수 있도록 명령하는 것!**

수행 방식 요약

1. 기존의 작업을 처리하던 도중, 인터럽트가 발생하면

2. 현재 컴퓨터가 처리하는 일을 중지하고 현재의 컴퓨터의 상태(CPU 내부의 레지스터, 메인 메모리 내용 등을)를 저장.

3. 해당하는 인터럽트를 처리해주기 위한 인터럽트 서비스 루틴을 처리.

4. 인터럽트 처리 이후 저장되었던 이전 작업의 상태를 복구하고 이전 작업 수행을 재개.

## 1-1. **내부/소프트웨어 인터럽트**

-   CPU내부에서 자신이 실행한 명령이나 CPU의 명령 실행에 관련된 모듈이 변화하는 경우 발생
-   프로그램의 오류에 의해 생기는 인터럽트

> 0으로 나누는 경우<br>
> OverFlow/UnderFlow<br>
> 페이지 부재<br>
> 부당한 기억장소의 참조 등등...

## 1-2 **외부 인터럽트**

-   전원 이상 인터럽트(Power fail interrupt): 정전, 파워 이상 등
-   기계 착오 인터럽트(Machine check interrupt): CPU의 기능적인 오류
-   외부 인터럽트(External interrupt)
    -   자원이 할당된 시간이 다 끝난 경우
    -   키보드로 인터럽트 키를 누른 경우(대표적으로 Control + Alt + Delete)
    -   외부장치로부터 인터럽트 요청이 있는 경우
-   입출력 인터럽트(I/O Interrupt)
    -   입출력장치가 데이터 전송을 요구하거나 전송이 끝나 다음 동작이 수행되어야 할 경우
    -   입출력 데이터에 이상이 있는 경우

---

# 2. **인터럽트의 정렬 방법**

## 인터럽트 우선 순위

1. 전원 공급의 이상
2. CPU의 기계적인 오류
3. 외부 신호에 의한 인터럽트
4. 입출력 전송 요청 및 전송 완료, 전송 오류
5. 프로그램 검사 인터럽트
6. 수퍼바이저 호출(SVC 인터럽트)

-   일반적으로 하드웨어 인터럽트가 소프트웨어 인터럽트보다 우선 순위가 높음

이런 인터럽트의 우선 순위를 정렬하기 위해 <b>소프트웨어적인 방법과 하드웨어적 방법</b>이 있음.

## 2-1. **소프트웨어적 방법**

-   폴링(Polling)
    -   CPU가 모든 제어기에 연결된 TEST I/O선을 이용해 인터럽트를 요청한 장치를 검사하는 방식.
    -   즉, 요청 플래그를 차례로 검사해 인터럽트 서비스 루틴을 수행하는 방식.
    -   하드웨어를 추가할 필요가 없어 회로가 간단하지만 CPU 자원이 필요해 반응 시간이 느림.
    -   많은 인터럽트가 있을 경우 하드웨어 적인 방법에 비해서 우선순위 판단 속도가 느리고 폴링의 주기가 짧으면 Server 성능에 부담이 생김.

## 2-2. **하드웨어적인 방법**

-   Vectored Interrupt

    -   인터럽트를 요청할 수 있는 장치와 CPU사이에 장치번호를 식별할 수 있는 버스를 직렬/병렬로 연결.
    -   인터럽트 벡터 : 인터럽트를 발생시킨 장치가 분기할 곳에 대한 정보
    -   소프트웨어적인 방법에 비해 비경제적
    -   회로가 복잡하지만 별도의 소프트웨어가 필요없이 하드웨어로 처리되므로 속도가 빠름.

    *   Daisy Chain
        -   인터럽트가 발생하는 모든 장치를 하나의 직렬 회선으로 연결.
        -   우선순위가 높은 장치를 상위에 두고 우선순위 차례대로 배치.
    *   병렬(Parallel) 우선순위 부여 방식
        -   인터럽트가 발생하는 모든 장치를 하나의 직렬 회선으로 연결한다.
        -   각 장치별 우선순위를 판별하기 위한 Mask register에 bit를 설정한다.
        *   Mask register상 우선순위가 높은 서비스 루틴 수행중 우선순위가 낮은 bit들을 비활성화 시킬 수 있다.
        *   반대로 우선순위가 높은 인터럽트는 낮은 인터럽트 수행 중에도 우선 처리된다.

---

# 3. **인터럽트의 처리**
![인터럽트](https://user-images.githubusercontent.com/71562311/199923820-2a090667-f5be-4107-bb2c-315488bb2357.png)

-   인터럽트 요청이 들어왔다고 바로 처리하는 것이 아니라, 명령어의 `실행`단계를 마쳐야 함!
-   명령어 사이클은 `인출`과 `실행` 두가지 단계를 반복적으로 수행함.
-   명령어의 `실행` 단계를 마칠 때마다 중앙처리장치는 반복적으로 인터럽트 요청이 있는지 확인함.
    -   인터럽트 요청이 있으면 인터럽트 서비스 단계를 진행!

![인터럽트 수행 과정](https://user-images.githubusercontent.com/71562311/199923855-87588a0b-6f42-49db-812b-f649c2294df3.png)


`인터럽트 서비스 루틴`은 결국 기억장치 내에 저장되어 있는 `프로그램`!

![인터럽트 지정](https://user-images.githubusercontent.com/71562311/199923847-e282eaf8-2b51-4146-a536-bb36d52f9343.jpg)

인터럽트 벡터의 일부, 이 표대로 인터럽트 상황을 처리함.

예외사항 인터럽트가 아니면 인터럽트의 번호는 `운영체제`가 결정함.

리눅스 기준

-   0 ~ 31 : 예외상황 인터럽트
-   32 ~ 47 : 하드웨어 인터럽트
-   128 : 시스템 콜
