이 문서는 2022년 11월 16일에 @codeing999에 의해서 작성되었습니다.
```
1. 물리 주소(physical address)와 논리 주소(logical address)
  1.1. 주소 변환
2. 페이징(Paging)
3. 세그멘테이션(Segmentation)
```

# 1. 물리 주소(physical address)와 논리 주소(logical address)
프로세스는 스왑아웃되고 그 후에 다시 스왑인 될 때, 마지막으로 적재되었던 파티션과는 다른 파티션에 적재될 수 있으므로 프로세스에 의해 참조된 명령어와 데이터의 위치는 고정되지 않는다.
이러한 문제를 해결하기 위해 프로세스 생성이나 실행에 사용되는 주소를 몇 가지 유형으로 구분한다.
- 논리 주소 : 현재 데이터가 적재된 메모리와는 독립적인 메모리 위치에 대한 참조. 이 주소는 실제 메모리 접근을 위해서 반드시 그 전에 물리 주소로 변환되어야 한다.
- 상대 주소 : 논리 주소의 특별한 예인데, 어떤 알려진 지점, 주로 프로세서의 한 레지스터 값으로부터 상대적인 위치를 의미하는 주소이다.
- 물리 주소 : 주기억장치 내에서의 실제 위치

## 1.1. 주소 변환(Address Translation)
일반적으로 적재된 프로세스의 모든 메모리 참조는 프로그램의 시작 주소로부터 상대적이므로 
특정 부분을 참조하는 명령어를 실행할 때 그 상대 주소를 주기억장치의 물리 주소로 변환시켜 주기 위한 하드웨어 장치가 요구된다.

![image](https://user-images.githubusercontent.com/109027875/202052362-661f366f-30b7-477e-9812-c9974e792ac8.png)
- 베이스 레지스터 : 프로그램이 적재되어 있는 주기억장치의 시작 주소가 적재된 레지스터
- 경계(bounds) 레지스터 : 프로그램의 마지막 위치를 가리키는 레지스터
- 프로세스를 실행하는 동안에는 상대 주소가 이용되는데 두 가지 처리 과정을 거친다.
  - 우선, 베이스 레지스터 값이 이 상대 주소에 더해져서 절대 주소로 변환된다.
  - 그런 다음, 이 절대 주소가 경계 레지스터 값과 비교된다. 만약 주소가 경계 범위 내에 있다면 명령이 실행되고 그렇지 않다면 운영체제로 인터럽트가 발생된다. 

> 단편화 문제를 해결하기 위한 기법으로 페이징과 세그멘테이션이 있다.

# 2. 페이징(Paging)
- 메모리를 비교적 작은 고정 크기 파티션으로 나누고, 각 프로세스 또한 같은 크기의 고정 조각으로 나눈다. 이 프로세스 조각인 페이지는 하고 빈 메모리 조각인 프레임에 저장될 수 있다.
  - 외부 단편화는 발생하지 않고 내부 단편화만 발생하는데 그것도 각 프로세스의 마지막 페이지에서만 발생한다.
- 논리 주소 개념을 사용하여 프로세스를 페이지 단위로 메모리의 불연속적으로 저장한다.
  - 운영체제는 각 프로세스마다 하나의 페이지 테이블(page table)을 유지하여 프로세스의 각 페이지들에 해당하는 프레임의 위치를 관리한다.
  - 논리 주소(페이지 번호, 오프셋)가 주어지면, 프로세서는 페이지 테이블을 이용하여 물리 주소(프레임 숫자, 오프셋)를 생성한다.
![image](https://user-images.githubusercontent.com/109027875/203309849-0749616b-38e9-4231-8496-b373c253f593.png)
> 고정분할 방법과 비교
> 
> 페이징이 고정 분할 방법과 다른 점은 파티션의 크기가 보다 작고, 한 프로그램이 하나 이상의 파티션을 차지할 수 있으며, 이 파티션들이 반드시 연속일 필요는 없다는 점이다.

# 3. 세그멘테이션(Segmentation)
 ![image](https://user-images.githubusercontent.com/109027875/203309941-a6e8b480-b4ae-4eb9-a5a1-52a75288d1a3.png)

# references
- 박미진 컴퓨터 일반
- 운영체제 내부 구조 및 설계 원리
- [페이징&세그멘테이션](https://dar0m.tistory.com/269)
