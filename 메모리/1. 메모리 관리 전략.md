이 문서는 2022년 11월 12일에 @codeing999에 의해서 작성되었습니다.
```
1. 메모리 관리 정책
  1.1. 반입(Fetch) 정책
  1.2. 배치(Placement) 정책
  1.3. 교체(Replacement) 정책
2. 메모리 관리 기법
  2.1. 분할(Partitioning)
    2.1.1. 고정 분할(Fixed Partitioning)
    2.1.2. 동적 분할(Dynamic Partitioning)
```

# 1. 메모리 관리 정책

## 1.1. 반입(Fetch) 정책
- 페이지를 메모리로 가져올 시기를 결정하는 정책
- 요구반입 : 실행 중인 프로그램에 의해 어떤 프로그램이나 자료가 참조될 때 그것을 메모리로 옮긴다.
- 예상반입 : 현 프로그램 수행 중에 앞으로 요구될 가능성이 큰 자료 또는 프로그램을 예상하여 메모리로 미리 옮긴다.

## 1.2. 배치(Placement) 정책
- 새로 반입된 자료나 프로그램을 메모리의 어디에 위치시킬 것인가를 결정하는 정책
- 최초 적합(First Fit)
      - 사용가능공간 리스트에서 충분히 큰 첫 번째 공백 분할 공간에 할당한다.
      - 속도가 빠를 수 있지만 공간 활용률은 떨어진다.
- 최적 적합(Best Fit)
      - 충분히 큰 사용가능 공간 중 가장 작은 크기의 사용 공간을 할당한다.
      - 리스트가 정렬되어 있지 않다면 전체 리스트를 검색해야 한다.
      - 사용가능 공간 이용률은 향상될 수 있으나 속도가 느리다.
## 1.3. 교체(Replacement) 정책
- 새로 들어온 프로그램이 들어갈 장소를 마련하기 위해서 어떤 프로그램이나 자료를 메모리로부터 제거할 것인가를 결정하는 정책으로 가상메모리에서 이용된다.

# 2. 메모리 관리 기법

## 2.1. 분할(Partitioning)
### 2.1.1. 고정 분할(Fixed Partitioning)
- 균등 분할 : 모두 같은 크기로 분할
  - 배치 알고리즘은 모두 같은 크기이므로 최초 적합
  - 문제점
    - 프로그램이 파티션 보다 클 수 있다. 이러한 경우, 프로그래머는 오버레이를 사용하는 프로그램을 설계하여 어느 순간에는 프로그램의 필요한 부분만 메모리에 있도록 해야 한다. 현재 적재되어 있지 않은 모듈이 필요하다면, 사용자 프로그램은 해당 프로그램의 파티션에 어떤 프로그램이나 데이터가 있든 간에 덮어 써서 원하는 모듈을 적재시킨다.
    - 메모리 이용률이 매우 저조하다. 매우 작은 크기의 프로그램이라도 전체의 파티션을 차지한다. 예를 들어, 2MB보다 작은 프로그램이 있다고 하자. 그러나 이 프로그램은 스왑인이 될 때 8MB의 파티션을 차지한다. 이처럼 적재되는 데이터가 파티션보다 작을 때 파티션 내부 공간의 낭비가 발생하는 현상을 내부 단편화라고한다.
- 비균등 분할 : 균등 분할의 문제를 완전히는 해결하지 못하지만 영향을 줄일 수 있다. 
  - 배치 알고리즘은 최적적합을 사용할 수 있다.

![image](https://user-images.githubusercontent.com/109027875/201478313-ef9f9403-034c-44d1-9f57-d28669474207.png)


### 2.1.2. 동적 분할(Dynamic Partitioning)
- 고정 분할 기법에서 발생하는 몇 가지 문제점을 해결하기 위해 개발되었지만 이 역시 더 정교한 관리 기술로 대체되었다.
- 파티션의 크기와 개수가 가변적으로 한 프로세스가 메모리에 적재될 때 정확히 요구된 크기만큼의 메모리만 할당받는다.
  - 문제점
    - 외부 단편화(external fragmentation) : 모든 파티션 영역 이외의 메모리가 점차 사용할 수 없는 조각으로 변하는 현상

![image](https://user-images.githubusercontent.com/109027875/201482827-b0a8ff0b-7224-4338-9d50-1b303717cbd8.png)
